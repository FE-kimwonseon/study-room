# 이벤트 처리 (Event Handling)

React에서 이벤트를 처리하는 방법은 DOM 요소의 이벤트 처리와 유사하지만, 몇 가지 문법적 차이와 React만의 특징이 있습니다. 사용자의 클릭, 입력, 마우스 움직임 등 다양한 상호작용을 처리하는 방법을 작성했습니다.

<br/>

## React 이벤트의 특징

### 1. 이벤트 이름은 camelCase

HTML엣서는 소문자로 작성하지만, React에서는 **camelCase**를 사용합니다.

```jsx
// HTML
<button onclick="handleClick()">클릭</button>

// React
<button onClick={handleClick}>클릭</button>
```

### 2. 이벤트 핸들러로 함수를 전달

문자열이 아닌 **함수 자체**를 전달합니다. 중괄호 `{}`를 사용하여 JavaScript표현식으로 전달합니다.

```jsx
// 잘못된 예: 함수를 호출하면 안됨
<button onClick={handleClick()}>클릭</button>   // X 즉시 실행됨

// 올바른 예: 함수 자체를 전달
<button onClick={handleClick}>클릭</button>     // O 클릭 시 실행
```

### 3. 합성 이벤트 (SyntheticEvent)

React는 브라우저의 네이티브 이벤트를 감싸는 **SyntheticEvent** 객체를 사용합니다. 이를 통해 모든 브라우저에서 동일하게 작동하도록 보장합니다.

```jsx
function handleClick(e) {
  // e는 React의 SyntheticEvent 객체
  console.log(e.type); // 'click'
  console.log(e.target); // 클릭된 요소
  console.log(e.currentTarget); // 이벤트 핸들러가 부착된 요소
}
```

<br/>

## 이벤트 핸들러 작성 패턴

### 1. 컴포넌트 내부에 함수 정의

일반적인 패턴

```jsx
function Button() {
  // 이벤트 핸들러 함수 정의
  const handleClick = () => {
    alert("버튼이 클릭되었습니다.");
  };

  return <button onClick={handleClick}>클릭</button>;
}
```

### 2. 인라인 화살표 함수

간단한 로직이나 인자를 전달해야 할 때 사용

```jsx
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: "리액트 공부" },
    { id: 2, text: "운동하기" },
  ]);

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          {todo.text}
          {/* 인라인 화살표 함수로 id 전달 */}
          <button onClick={() => deleteTodo(todo.id)}>삭제</button>
        </li>
      ))}
    </ul>
  );

  function deleteTodo(id) {
    setTodos(todos.filter((todo) => todo.id !== id));
  }
}
```

### 3. 이벤트 핸들러에 매개변수 전달하기

여러 방법으로 이벤트 핸들러에 추가 데이터를 전달

```jsx
function ItemList() {
  const handleAction = (action, itemId) => {
    console.log(`${action}: ${itemId}`);
  };

  return (
    <div>
      {/* 방법 1: 화살표 함수 사용 */}
      <button onClick={() => handleAction("edit", 1)}>수정</button>

      {/* 방법 2: bind 사용 (잘 사용하지 않음) */}
      <button onClick={handleAction.bind("edit", 1)}>삭제</button>

      {/* 방법 3: 데이터 속성 사용 */}
      <button
        data-action="view"
        data-id="1"
        onClick={(e) => {
          const action = e.target.dataset.action;
          const id = e.target.dataset.id;
          handleAction("edit", 1);
        }}>
        보기
      </button>
    </div>
  );
}
```

<br />

## 자주 사용하는 이벤트 타입

### 마우스 이벤트

```jsx
function MouseEvents() {
  return (
    <div
      onClick={() => console.log("클릭")}
      onDoubleClick={() => console.log("더블클릭")}
      onMouseEnter={() => console.log("마우스 진입")}
      onMouseLeave={() => console.log("마우스 나감")}
      onMouseMove={() => console.log(`좌표: ${e.clientX}, ${e.clientY}`)}
      style={{ padding: "20px", border: "1px solid #ccc" }}>
      마우스 이벤트 영역
    </div>
  );
}
```

### 폼 이벤트

```jsx
function FormEvents() {
  const [value, setValue] = useState("");

  const handleSubmit = (e) => {
    e.preveventDefault(); // 폼 제출 시 페이지 새로고침 방지
    console.log("제출된 값:", value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
        onFocus={() => console.log("포커스 됨")}
        onBlur={() => console.log("포커스 잃음")}
      />
      <button type="submit">제출</button>
    </form>
  );
}
```

### 키보드 이벤트

```jsx
function KeyboardEvents() {
  const handleKeyDown = (e) => {
    if (e.key === "Enter") {
      console.log("엔터키 눌림");
    } else if (e.key === "Escape") {
      console.log("ESC키 눌림");
    }

    // 조합키 확인
    if (e.ctrlKey && e.key === "s") {
      e.preventDefault(); // 브라우저 기본 저장 동작 방지
      console.log("Ctrl+S 눌림");
    }
  };

  return (
    <input
      type="text"
      onKeyDown={handleKeyDown}
      onKeyUp={(e) => console.log("키 떼짐:", e.key)}
      onKeyPress={(e) => console.log("키 눌림:", e.key)}
    />
  );
}
```

<br />

## 이벤트 전파와 기본 동작

### `preventDefault()`: 기본 동작 방지

브라우저의 기본 동작을 막을 때 사용

```jsx
function LinkWithoutNavigation() {
  const handleClick = (e) => {
    e.preventDefault(); // 링크 이동 방지
    console.log("링크 클릭됨, 하지만 이동하지 않음");
  };

  return (
    <a href="https://google.com" onClick={handleClick}>
      구글로 가지 않은 링크
    </a>
  );
}
```

### `stopPropagation()`: 이벤트 버블링 중단

이벤트가 부모 요소로 전파되는 것을 막음

```jsx
function EventBubbling() {
  return (
    <div onClick={() => console.log("부모 클릭")}>
      부모 영역
      <button
        onClick={(e) => {
          e.stopPropagation(); // 부모로 이벤트 전파 중단
          console.log("자식 클릭");
        }}>
        자식 버튼
      </button>
    </div>
  );
}
```

<br />

## 이벤트 핸들러 네이밍 컨벤션

일관된 네이밍은 코드의 가독성을 높임

```jsx
function NamingConvention() {
  // handle + 이벤트명
  const handleClick = () => {};
  const handleSubmit = () => {};
  const handleChange = () => {};

  // on + 이벤트명 (props로 전달받을 때)
  return <CustomButton onClick={handleClick} />;
}

// 컴포넌트가 props로 이벤트 핸들러를 받을 때
function CustomButton({ onClick, onHover }) {
  return (
    <button onClick={onClick} onMouseEnter={onHover}>
      커스텀 버튼
    </button>
  );
}
```

<br />

## 주의사항과 팁

### 1. 함수를 즉시 호출하지 않기

```jsx
// 잘못된 예: 렌더링 시 즉시 실행됨
<button onClick={alert('클릭')}>클릭</button>

// 올바른 예: 함수를 전달
<button onClick={() => alert('클릭')}>클릭</button>
```

### 2. this 바인딩 (클래스 컴포넌트)

함수 컴포넌트를 사용한다면 this 바인딩을 걱정할 필요가 없음

### 3. 성능 최적화

이벤트 핸들러가 자주 재생성되는 것이 걱정된다면 `useCallback`을 사용할 수 있음

```jsx
import { useCallback } from "react";

function OptimizedComponent({ data }) {
  // 의존성이 변경될 때만 함수 재생성
  const handleClick = useCallback(() => {
    console.log(data);
  }, [data]);

  return <ExpensiveChildComponent onClick={handleClick} />;
}
```

### 4. 이벤트 위임 활용

많은 요소에 동일한 이벤트를 적용할 때는 부모 요소에 하나의 핸들러만 두는 것이 효율적임

```jsx
function EventDelegation() {
  const handleClick = (e) => {
    // 실제 클릭된 요소 확인
    if (e.target.tagName === "BUTTON") {
      const action = e.target.dataset.action;
      console.log(`Action: ${action}`);
    }
  };

  return (
    <div onClick={handleClick}>
      <button data-action="save">저장</button>
      <button data-action="edit">수정</button>
      <button data-action="delete">삭제</button>
    </div>
  );
}
```

<br/>

## 동적 폼 처리

```jsx
function DynamicForm() {
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    message: "",
  });

  // 하나의 핸들러로 모든 입력 처리
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log("폼 데이터:", formData);
    // API 호출 등 처리
  };

  const handleReset = () => {
    setFormData({
      username: "",
      email: "",
      message: "",
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="username"
        value={formData.username}
        onChange={handleInputChange}
        placeholder="사용자명"
      />
      <input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleInputChange}
        placeholder="이메일"
      />
      <textarea
        name="message"
        value={formData.message}
        onChange={handleInputChange}
        placeholder="메시지"
      />
      <button type="submit">제출</button>
      <button type="button" onClick={handleReset}>
        초기화
      </button>
    </form>
  );
}
```

<br />

# 참고 자료

> [React 공식 문서 - 이벤트 처리하기](https://ko.react.dev/learn/responding-to-events)

> [React 공식 문서 - 이벤트 핸들러에서 Props 읽기](https://ko.react.dev/learn/passing-event-handlers-as-props)

> [MDN - 이벤트 레퍼런스](https://developer.mozilla.org/ko/docs/Web/Events)
