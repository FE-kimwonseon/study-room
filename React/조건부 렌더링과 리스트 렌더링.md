# 조건부 렌더링과 리스트 렌더링

React에서는 JavaScript의 조건문과 배열 메서드를 활용하여 **상황에 따라 다른 UI를 보여주거나(조건부 렌더링), 데이터 배열을 UI목록으로 변환(리스트 렌더링)** 할 수 있습니다

<br/>

## 조건부 렌더링 (Conditional Rendering)

조건부 렌더링은 특정 조건에 따라 다른 컴포넌트나 요소를 화면에 표시하는 기법입니다. 로그인 상태, 로딩 상태, 에러 발생 여부 등에 따라 다른 UI를 보여줄 때 사용합니다.

### 1. if문 사용하기

가장 직관적인 방법입니다. JSX를 변수에 저장하고 조건에 따랄 다른 값을 할당합니다.

```jsx
function Greeting({ isLoggedIn }) {
  let message;

  if (isLoggedIn) {
    message = <h1>환영합니다! 회원님</h1>;
  } else {
    message = <h1>로그인이 필요합니다.</h1>;
  }

  return <div>{message}</div>;
}
```

### 2. 삼항 연산자 (Ternary Operator) `? :`

짧은 조건부 렌더링에 가장 많이 사용됩니다. JSX 내부에서 직접 사용할 수 있어 편리합니다.

```jsx
function UserStatus({ isOnline }) {
  return (
    <div>
      {isOnline ? (
        <span style={{ color: "green" }}>온라인</span>
      ) : (
        <span style={{ color: "gray" }}>온라인</span>
      )}
    </div>
  );
}
```

### 3. 논리 AND 연산자 `&&`

조건이 참일 때만 무언가를 렌더링하고, 거짓일 때는 아무것도 렌더링하지 않을 때 사용합니다.

```jsx
function Notification({ hasNewMessage, messageCount }) {
  return (
    <div>
      <h1>알림</h1>
      {hasNewMessage && <p>새로운 메시지가 {messageCount}개 있습니다!</p>}
    </div>
  );
}
```

> **주의사항:** `&&` 왼쪽의 값이 `0`이나 `''`(빈 문자열)일 때 그 값이 그대로 렌더링될 수 있습니다.

```jsx
// 잘못된 예: count가 0일 때 화면에 0이 표시됨
{
  count && <p>장바구니: {count}개</p>;
}

// 올바른 예: 명시적으로 boolean으로 변환
{
  count > 0 && <p>장바구니: {count}개</p>;
}
```

### 즉시 실행 함수 (IIFE)

복잡한 조건 로직이 필요할 때 JSX 내부에서 사용할 수 있습니다.

```jsx
function Dashboard({ user, isLoading, error }) {
  return (
    <div>
      {(() => {
        if (isLoading) return <p>로딩 중...</p>;
        if (error) return <p>에러 발생: {error.message}</p>;
        if (!user) return <p>안녕하세요. {user.name}님!</p>;
      })()}
    </div>
  );
}
```

<br />

## 리스트 렌더링 (List Rendering)

배열 데이터를 React 엘리먼트 목록으로 변환하여 화면에 표시하는 기법입니다. JavaScript의 `map()` 메서드를 주로 사용합니다.

### 기본 사용법

```jsx
function TodoList() {
  const todos = ["공부하기", "운동하기", "책 읽기"];

  return (
    <ul>
      {todos.map((todo, index) => (
        <li key={index}>{todo}</li>
      ))}
    </ul>
  );
}
```

### 객체 배열 렌더링

주로 개발할 때 객체 배열을 다룹니다.

```jsx
function UserList() {
  const users = [
    { id: 1, name: "Alex", age: 30 },
    { id: 2, name: "Bob", age: 25 },
    { id: 3, name: "Chris", age: 35 },
  ];

  return (
    <div>
      <h2>사용자 목록</h2>
      {users.map((user) => (
        <div key={user.id} className="user-card">
          <h3>{user.name}</h3>
          <p>나이: {user.age}세</p>
        </div>
      ))}
    </div>
  );
}
```

<br />

## Key속성의 중요성

리스트를 렌더링할 때 각 항목에는 **고유한`Key`속성**이 필요합니다. React는 이 key를 통해 어떤 항목이 변경, 추가, 삭제되었는지 효율적으로 파악합니다.

### Key 선택 가이드

1. 최선: 데이터의 고유 ID 사용

```jsx
{
  users.map((user) => <UserCard key={user.id} {...user} />);
}
```

2. 차선: 안정적인 고유값 생성

```jsx
{
  items.map((item) => <Item key={`${item.category}-${item.name}`} {...item} />);
}
```

3. 최후: 인덱스 사용 (권장하지 않음)

```jsx
{
  items.map((item, index) => <Item key={index} {...item} />);
}
```

> ### Key 사용 시 주의사항

- **Key는 형제 요소 간에만 고유하면 됩니다.** 전체 애플리케이션에서 고유할 필요 없습니다.

- **Key를 컴포넌트의 props로 받을 수 없습니다.** 필요하다면 다른 이름의 prop으로 전달합니다.

- **`Math.random()`을 key로 사용하면 안됩니다.** 렌더링할 때마다 새로운 key가 생성되어 성능 문제가 발생합니다.

<br />

## 리스트 필터링과 정렬

`map()`과 함께 `filter()`, `sort()`등을 조합하여 동적인 리스트를 만들 수 있습니다.

```jsx
function ProductList({ products, maxPrice }) {
  const [sortBy, setSortBy] = useState("name");

  // 필터링과 정렬을 체이닝
  const displayedProducts = products
  .filter((product) => product.price <= maxPrice)   // 가격 필터링
  .sort((a, b) => {                                 // 정렬
    if(sortBy === 'name') {
        return a.name.localeCompare(b.name);
    }
    return a.price - b.price;
  });

  return (
    <div>
    <selct onChange={(e) => setSortBy(e.target.value)}>
    <option value="name">이름순</option>
    <option value="price">가격순</option>

    <ul>
    {displayedProducts.map(product => (
        <li key={product.id}>
            {product.name} - {product.price}원
        </li>
    ))}
    </ul>
    </div>
  );
}
```

<br />

## 조건부 렌더링과 리스트 렌더링 조합

보통 개발에서는 두 기법을 함께 사용하는 경우가 많다.

```jsx
function TodoApp({ todos, isLoading, error }) {
  if (isLoading) {
    return <div>할 일 목록을 불러오는 중</div>;
  }

  if (error) {
    return <div>에러가 발생했습니다: {error.message}</div>;
  }

  return (
    <div>
      <h1>오늘의 할 일</h1>
      {todos.length === 0 ? (
        <p>할 일이 없습니다. 새로운 할 일을 추가해보세요!</p>
      ) : (
        <ul>
          {todos.map((todo) => (
            <li key={todo.id}>
              <span style={{ textDecoration: todo.completed ? "line-through" : "none" }}>
                {todo.text}
              </span>
              {todo.completed && <span> Check</span>}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

<br />

# 참고 자료

> [React 공식 문서 - 조건부 렌더링](https://ko.react.dev/learn/conditional-rendering)

> [React 공식 문서 - 리스트와 Key](https://ko.react.dev/learn/rendering-lists)
